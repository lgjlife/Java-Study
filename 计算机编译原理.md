<!-- TOC -->

- [1. 编译原理](#1-编译原理)
  - [1.1. 概论](#11-概论)
    - [1.1.1. 与编译器相关的程序](#111-与编译器相关的程序)
    - [1.1.2. 翻译步骤](#112-翻译步骤)
    - [1.1.3. 编译器中的主要数据结构](#113-编译器中的主要数据结构)
  - [1.2. 词法分析](#12-词法分析)
  - [1.3. 上下文无关及分析](#13-上下文无关及分析)
  - [1.4. 自顶向下分析](#14-自顶向下分析)
  - [1.5. 自底向上分析](#15-自底向上分析)
  - [1.6. 语义分析](#16-语义分析)
  - [1.7. 运行时环境](#17-运行时环境)
  - [1.8. 代码生成](#18-代码生成)

<!-- /TOC -->
# 1. 编译原理
<a href="#menu"  >目录</a>

## 1.1. 概论
<a href="#menu"  >目录</a>

编译器是一种将语言翻译为另一种语言的计算机程序.将源代码转换成目标语言(机器语言).编程语言由最初的二进制代码转变成汇编代码,最后又产生更加友好的高级语言,由于计算机只能识别机器语言(二进制).因此需要通过编译器将高级语言编译成二进制代码.

### 1.1.1. 与编译器相关的程序

**解释程序（interpreter）**

解释程序是如同编译器的一种语言翻译程序。它与编译器的不同之处在于：它立即执行源程序而不是生成在翻译完成之后才执行的目标代码。从原理上讲，任何程序设计语言都可被解释或被编译，但是根据所使用的语言和翻译情况，很可能会选用解释程序而不用编译器

* 主体不同
    * 编译执行：由编译程序将目标代码一次性编译成目标程序，再由机器运行目标程序。
    * 解释执行：将源语言直接作为源程序输入，解释执行解释一句后就提交计算机执行一句，并不形成目标程序。
* 优势不同
    * 编译执行：相比解释执行编译执行效率高，占用资源小，适合复杂程序
    * 解释执行：开发速度快，出现严重BUG的几率小。
* 缺点不同
    * 编译执行：兼容性差，例如在windows平台上版写的编译程序一般不可以在unix平台上运行。
    * 解释执行：解析需要时间，不生权成目标程序而是一句一句的执行的方式会造成计算机资源的浪费，即执行效率低。

**汇编程序(assember)**

汇编程序是用于特定计算机上的汇编语言的翻译程序。正如前面所提到的，汇编语言是计算机的机器语言的符号形式，它极易翻译。有时，编译器会生成汇编语言以作为其目标语言，然后再由一个汇编程序将它翻译成目标代码

**连接程序（linker）**

编译器和汇编程序都经常依赖于连接程序，它将分别在不同的目标文件中编译或汇编的代码收集到一个可直接执行的文件中。在这种情况下，目标代码，即还未被连接的机器代码，与可执行的机器代码之间就有了区别。连接程序还连接目标程序和用于标准库函数的代码，以及连接目标程序和由计算机的操作系统提供的资源（例如，存储分配程序及输入与输出设备） 。有趣的是，连接程序现在正在完成编译器最早的一个主要活动（这也是“编译”一词的用法，即通过收集不同的来源来构造） 。

**装入程序（loader）**

编译器、汇编程序或连接程序生成的代码经常还不完全适用或不能执行，但是它们的主要存储器访问却可以在存储器的任何位置中且与一个不确定的起始位置相关。这样的代码被称为是可重定位的（relocatable），而装入程序可处理所有的与指定的基地址或起始地址有关的可重定位的地址。装入程序使得可执行代码更加灵活，但是装入处理通常是在后台（作为操作环境的一部分）或与连接相联合时才发生，装入程序极少会是实际的独立程序。

**预处理器（ preprocessor）**

预处理器是在真正的翻译开始之前由编译器调用的独立程序。预处理器可以删除注释、包含其他文件以及执行宏（宏 macro是一段重复文字的简短描写）替代。预处理器可由语言（如C）要求或以后作为提供额外功能的附加软件。

### 1.1.2. 翻译步骤

![编译器的阶段](pic/computer-base/编译器/编译器的阶段.png)


**扫描程序(scaner)**
在这个阶段编译器实际阅读源程序（通常以字符流的形式表示 ） 。扫描程序执行词法分析（Lexicalanalysis）：它将字符序列收集到称作记号（token）的有意义单元中，记号同自然语言，如英语中的字词相似。因此可以认为扫描程序执行与拼写相似的任务。

**语法分析程序(parser)**
语法分析程序从扫描程序中获取记号形式的源代码，并完成定义程序结构的语法分析（ syntax analysis） ，这与自然语言中句子的语法分析类似。语法分析定义了程序的结构元素及其关系。通常将语法分析的结果表示为分析树（ parse tree）或语法树（ syntax tree）

**语义分析程序（ semantic analyzer）**
程序的语义就是它的“意思”，它与语法或结构不同。程序的语义确定程序的运行，但是大多数的程序设计语言都具有在执行之前被确定而不易由语法表示和由分析程序分析的特征。这些特征被称作静态语义（static semantic），而语义分析程序的任务就是分析这样的语义（程序的“动态”语义具有只有在程序执行时才能确定的特性，由于编译器不能执行程序，所以它不能由编译器来确定）。一般的程序设计语言的典型静态语义包括声明和类型检查。由语义分析程序计算的额外信息（诸如数据类型）被称为属性（attribute），它们通常是作为注释或“装饰”增加到树中（还可将属性添加到符号表中）。

**源代码优化程序（ source code optimizer）**
编译器通常包括许多代码改进或优化步骤。绝大多数最早的优化步骤是在语义分析之后完成的，而此时代码改进可能只依赖于源代码。这种可能性是通过将这一操作提供为编译过程中的单独阶段指出的。每个编译器不论在已完成的优化种类方面还是在优化阶段的定位中都有很大的差异。

**代码生成器（ code generator）**
代码生成器得到中间代码（ I R），并生成目标机器的代码。尽管大多数编译器直接生成目标代码.

**目标代码优化程序（ target code optimizer）**
在这个阶段中，编译器尝试着改进由代码生成器生成的目标代码。这种改进包括选择编址模式以提高性能、将速度慢的指令更换成速度快的，以及删除多余的操作。

### 1.1.3. 编译器中的主要数据结构
<a href="#menu"  >目录</a>

**记号（token）**
当扫描程序将字符收集到一个记号中时，它通常是以符号表示这个记号；这也就是说，作为一个枚举数据类型的值来表示源程序的记号集。有时还必须保留字符串本身或由此派生出的其他信息（例如：与标识符记号相关的名字或数字记号值）。在大多数语言中，扫描程序一次只需要生成一个记号（这称为单符号先行（singlesymbollookahead））。在这种情况下，可以用全程变量放置记号信息；而在别的情况（最为明显的是FORTRAN）下，则可能会需要一个记号数组。

**语法树（syntaxtree）**
如果分析程序确实生成了语法树，它的构造通常为基于指针的标准结构，在进行分析时动态分配该结构，则整棵树可作为一个指向根节点的单个变量保存。结构中的每一个节点都是一个记录，它的域表示由分析程序和之后的语义分析程序收集的信息。例如，一个表达式的数据类型可作为表达式的语法树节点中的域。有时为了节省空间，这些域也是动态分配或存放在诸如符号表的其他数据结构中，这样就可以有选择地进行分配和释放。实际上，根据它所表示的语言结构的类型（例如：表达式节点对于语句节点或声明节点都有不同的要求），每一个语法树节点本身都可能要求存储不同的属性。在这种情况下，可由不同的记录表示语法树中的每个节点，每个节点类型只包含与本身相关的信息。

**符号表（symboltable）**
这个数据结构中的信息与标识符有关：函数、变量、常量以及数据类型。符号表几乎与编译器的所有阶段交互：扫描程序、分析程序或将标识符输入到表格中的语义分析程序；语义分析程序将增加数据类型和其他信息；优化阶段和代码生成阶段也将利用由符号表提供的信息选出恰当的代码。因为对符号表的访问如此频繁，所以插入、删除和访问操作都必须比常规操作更有效。尽管可以使用各种树的结构，但杂凑表却是达到这一要求的标准数据结构。有时在一个列表或栈中可使用若干个表格。

**常数表（literaltable）**
常数表的功能是存放在程序中用到的常量和字符串，因此快速插入和查找在常数表中也十分重要。但是，在其中却无需删除，这是因为它的数据全程应用于程序而且常量或字符串在该表中只出现一次。通过允许重复使用常量和字符串，常数表对于缩小程序在存储器中的大小显得非常重要。在代码生成器中也需要常数表来构造用于常数和在目标代码文件中输入数据定义的符号地址。

**中间代码（intermediatecode）**
根据中间代码的类型（例如三元式代码和P-代码）和优化的类型，该代码可以是文本串的数组、临时文本文件或是结构的连接列表。对于进行复杂优化的编译器，应特别注意选择允许简单重组的表示。

**临时文件（temporaryfile）**
计算机过去一直未能在编译器时将整个程序保留在存储器中。这一问题已经通过使用临时文件来保存翻译时中间步骤的结果或通过“匆忙地”编译（也就是只保留源程序早期部分的足够信息用以处理翻译）解决了。存储器的限制现在也只是一个小问题了，现在可以将整个编译单元放在存储器之中，特别是在可以分别编译的语言中时。但是偶尔还是会发现需要在某些运行步骤中生成中间文件。其中典型的是0代码生成时需要反填（backpatch）地址
```c
f x = 0 then ... else ...
在知道e l s e部分代码的位置之前必须由文本跳到 e l s e部分：

CMP X, 0
JNE NEXT ;; location of NEXT not yet known
< code for then-part >
N E X T :
< code for else-part >

通常，必须为N E X T的值留出一个空格，一旦知道该值后就会将该空格填上，利用临时文件可以很容易地做到这一点。
```


## 1.2. 词法分析
<a href="#menu"  >目录</a>

## 1.3. 上下文无关及分析
<a href="#menu"  >目录</a>

## 1.4. 自顶向下分析
<a href="#menu"  >目录</a>

## 1.5. 自底向上分析
<a href="#menu"  >目录</a>

## 1.6. 语义分析
<a href="#menu"  >目录</a>

## 1.7. 运行时环境
<a href="#menu"  >目录</a>

## 1.8. 代码生成
<a href="#menu"  >目录</a>
